# -*- coding: utf-8 -*-
"""Copia de MiPrimerCódigo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t82fhT8MNZg_BX1N7QkQAqFKuTqhGQkW
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
df = pd.read_csv('/content/drive/My Drive/GRAFICACIÓN/data.csv')

!pip install tensorflow==2.8.0
!pip install keras==2.8.0

import pandas as pd
import numpy as np
import os
import PIL
import seaborn as sns
import pickle
from PIL import *
import cv2
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.applications import DenseNet121
from tensorflow.keras.models import Model, load_model
from tensorflow.keras.initializers import glorot_uniform
from tensorflow.keras.utils import plot_model
from tensorflow.keras.callbacks import ReduceLROnPlateau, EarlyStopping, ModelCheckpoint, LearningRateScheduler
from IPython.display import display
#from tensorflow.python.keras import * -> PARA LAS NUEVAS VERSIONES DE TF, HACE QUE NO FUNCIONE
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras import layers, optimizers
from tensorflow.keras.applications.resnet50 import ResNet50
from tensorflow.keras.layers import *
from tensorflow.keras import backend as K
#from keras import optimizers -> PARA LAS NUEVAS VERSIONES DE TF, HACE QUE NO FUNCIONE
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from google.colab.patches import cv2_imshow

# Cargar los puntos faciales clave
keyfacial_df = pd.read_csv('/content/drive/My Drive/GRAFICACIÓN/data.csv')

keyfacial_df.head()

keyfacial_df.isnull().sum()

keyfacial_df['Image'].shape

# Dado que los valores para la imagen se dan como cadenas separadas por espacios
# separamos los valores usando ' ' como separador.
# Luego convertimos esto en una matriz numérica usando np.fromstring y la
# convertimos en una matriz unidimensional 1D obtenida de una matriz 2D de forma
# (96 * 96)
keyfacial_df['Image'] = keyfacial_df['Image'].apply(lambda x: np.fromstring(x, dtype = int, sep = ' ').reshape(96, 96))

# Obtain the shape of the image
keyfacial_df['Image'][0].shape

"""MINI RETO #1:
- Obtenga los valores promedio, mínimo y máximo para 'right_eye_center_x'.
"""

# right_eye_center_x = keyfacial_df[min]
# right_eye_center_x.head()
# keyfacial_df.right_eye_center_x
keyfacial_df.describe()

# Representamos una imagen aleatoria del conjunto de datos junto con puntos clave faciales.
# Los datos de la imagen se obtienen de df ['Image'] y se representan usando plt.imshow
# 15 coordenadas x e y para la imagen correspondiente dado que las coordenadas x están en columnas pares como 0, 2, 4,... y las coordenadas y están en columnas impares como 1, 3 ,5,...
# Accedemos a su valor usando el comando .loc, que obtiene los valores de las coordenadas de la imagen en función de la columna a la que se refiere.

i = np.random.randint(1, len(keyfacial_df))
plt.imshow(keyfacial_df['Image'][i],cmap = 'gray')
for j in range(1, 31, 2):
  plt.plot(keyfacial_df.loc[i][j - 1], keyfacial_df.loc[i][j], 'rx')

# Veamos más imágenes en formato matricial
fig = plt.figure(figsize = (20, 20))

for i in range(16):
  ax = fig.add_subplot(4, 4, i + 1)
  image = plt.imshow(keyfacial_df['Image'][i], cmap = 'gray')
  for j in range(1, 31, 2):
    plt.plot(keyfacial_df.loc[i][j - 1], keyfacial_df.loc[i][j], 'rx')

"""# MINIRETO 2

- Realiza una verificación adicional en los datos visualizando aleatoriamente 64 nuevas imágenes junto con sus puntos clave correspondientes.
"""

import random

fig = plt.figure(figsize = (20, 20))

for i in range(64):
  k = random.randint(1, len(keyfacial_df))
  ax = fig.add_subplot(8, 8, i + 1)
  image = plt.imshow(keyfacial_df['Image'][k], cmap = 'gray')
  for j in range(1, 31, 2):
    plt.plot(keyfacial_df.loc[i][j - 1], keyfacial_df.loc[i][j], 'rx')